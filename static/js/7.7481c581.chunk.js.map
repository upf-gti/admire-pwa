{"version":3,"sources":["assets/shader.fs","../lib/canvasRenderer/canvasRenderer.js","pages/Shader.jsx"],"names":["VERTEX_SOURCE","FRAGMENT_SOURCE","CanvasRenderer","canvas","HTMLCanvasElement","gl","getContext","handle","pixelSource","vertexBuffer","indexBuffer","textureCoordinateBuffer","texture","program","stream","onUpdate","createShader","source","type","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","log","getShaderInfoLog","console","error","FRAGMENT_SHADER","split","map","v","k","toString","padStart","join","createProgram","vertexSource","fragmentSource","vertexShader","VERTEX_SHADER","fragmentShader","attachShader","deleteShader","linkProgram","setProgram","useProgram","bindBuffers","positionAttribute","getAttribLocation","size","FLOAT","normalized","stride","offset","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","enableVertexAttribArray","ELEMENT_ARRAY_BUFFER","textureCoordinateAttribute","setUniforms","uniform","getUniformLocation","uniform1i","render","HTMLImageElement","width","height","HTMLVideoElement","videoWidth","videoHeight","target","TEXTURE_2D","internalFormat","RGBA","format","UNSIGNED_BYTE","texImage2D","updateTexture","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","viewport","drawElements","TRIANGLES","UNSIGNED_SHORT","window","requestAnimationFrame","createBuffer","bufferData","Float32Array","STATIC_DRAW","Uint16Array","createTexture","activeTexture","TEXTURE0","bindTexture","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","pixels","Uint8Array","getCanvas","getStream","frameRate","undefined","captureStream","setSource","some","validateSource","setShader","setUpdate","callback","setInt","name","value","setFloat","uniform1f","setVector","vector","length","uniform2f","uniform3f","uniform4f","setMatrix","matrix","uniformMatrix2fv","uniformMatrix3fv","uniformMatrix4fv","start","stop","cancelAnimationFrame","canvasRef","useRef","useState","ctx","setCtx","media","useContext","MediaContext","current","a","performance","now","useEffect","fetch","Shader","then","text","video","localStream","document","createElement","muted","autoplay","playsinline","src","srcObject","addEventListener","readyState","play","pause","id","Row","Col","xs","ref","style","objectFit","maxHeight"],"mappings":"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","file":"static/js/7.7481c581.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/shader.0b6fb8d4.fs\";","\"use strict\";\r\n\r\nconst VERTEX_SOURCE =\r\n`\r\nattribute vec3 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = vec4(a_position, 1.0);\r\n    v_texcoord = a_texcoord;\r\n}\r\n`;\r\n\r\nconst FRAGMENT_SOURCE =\r\n`\r\nprecision mediump float;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform sampler2D u_frame;\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = texture2D(u_frame, v_texcoord);\r\n}\r\n`;\r\n\r\nexport function CanvasRenderer( canvas )\r\n{\r\n    if( !(canvas instanceof HTMLCanvasElement) )\r\n    {\r\n        return null;\r\n    }\r\n\r\n    let gl = canvas.getContext(\"webgl\");\r\n    let handle = null;\r\n    let pixelSource = null;\r\n\r\n    let vertexBuffer = null;\r\n    let indexBuffer = null;\r\n    let textureCoordinateBuffer = null;\r\n\r\n    let texture = null;\r\n    let unit = 0;\r\n    let program = null;\r\n\r\n    let stream = null;\r\n    let onUpdate = null;\r\n\r\n    /**\r\n     * Create the vertex, index and texture coordinate buffers.\r\n     */\r\n    let createBuffers = function()\r\n    {\r\n        // Vertex buffer.\r\n        let vertices = [1, 1, 0, 1, -1, 0, -1, -1, 0, -1, 1, 0];\r\n        vertexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\r\n        // Index buffer.\r\n        let indices = [0, 1, 2, 0, 2, 3];\r\n        indexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n\r\n        // Texture coordinate buffer.\r\n        let textureCoordinates = [1, 0, 1, 1, 0, 1, 0, 0];\r\n        textureCoordinateBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinateBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n    };\r\n\r\n    function setUpdate( callback ){\r\n        onUpdate = callback;\r\n    }\r\n\r\n    /**\r\n     * Create the target texture.\r\n     */\r\n    let createTexture = function()\r\n    {\r\n        texture = gl.createTexture();\r\n    \r\n        // Active the texture unit.\r\n        gl.activeTexture(gl.TEXTURE0 + unit);\r\n    \r\n        // Bind the texture to the texture unit.\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    \r\n        // Turn off mip maps and set wrapping to clamp to edge so it will work regardless of the dimensions of the video.\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    \r\n        let target = gl.TEXTURE_2D;\r\n        let level = 0;\r\n        let internalFormat = gl.RGBA;\r\n        let width = 1;\r\n        let height = 1;\r\n        let border = 0;\r\n        let format = gl.RGBA;\r\n        let type = gl.UNSIGNED_BYTE;\r\n        let pixels = new Uint8Array([0, 0, 0, 255]);\r\n        gl.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels);\r\n    };\r\n\r\n    /**\r\n     * Update the target texture.\r\n     */\r\n    let updateTexture = function( source )\r\n    {\r\n        let target = gl.TEXTURE_2D;\r\n        let level = 0;\r\n        let internalFormat = gl.RGBA;\r\n        let format = gl.RGBA;\r\n        let type = gl.UNSIGNED_BYTE;\r\n        gl.texImage2D(target, level, internalFormat, format, type, source);\r\n    };\r\n\r\n    /**\r\n     * Create a shader.\r\n     */\r\n    let createShader = function( source, type )\r\n    {\r\n        let shader = gl.createShader(type);\r\n        gl.shaderSource(shader, source);\r\n        gl.compileShader(shader);\r\n    \r\n        let compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if( !compiled )\r\n        {\r\n            let log = gl.getShaderInfoLog(shader);\r\n            console.error(`Error while compiling  ${type === gl.FRAGMENT_SHADER?\"fragment\":\"vertex\"} shader: `,log);\r\n            console.error(source.split(\"\\n\").map( (v,k) => `${k.toString().padStart(4, '0')}\\t${v}`).join(\"\\n\"));\r\n            console.error(\"--------------------------------------------------------------------------------------\");\r\n            return null;\r\n        }\r\n    \r\n        return shader;\r\n    };\r\n\r\n    /**\r\n     * Create the program.\r\n     */\r\n    let createProgram = function( vertexSource, fragmentSource )\r\n    {\r\n        program = gl.createProgram();\r\n    \r\n        let vertexShader = createShader(vertexSource, gl.VERTEX_SHADER);\r\n        if( !vertexShader )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        let fragmentShader = createShader(fragmentSource, gl.FRAGMENT_SHADER);\r\n        if( !fragmentShader )\r\n        {\r\n            return false;\r\n        }\r\n    \r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n    \r\n        gl.deleteShader(vertexShader);\r\n        gl.deleteShader(fragmentShader);\r\n    \r\n        gl.linkProgram(program);\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Use the program.\r\n     */\r\n    let setProgram = function()\r\n    {\r\n        gl.useProgram(program);\r\n    };\r\n\r\n    /**\r\n     * Bind the vertex, index and texture coordinate buffers to the program.\r\n     */\r\n    let bindBuffers = function()\r\n    {\r\n        // Vertex buffer.\r\n        let positionAttribute = gl.getAttribLocation(program, \"a_position\");\r\n        let size = 3;\r\n        let type = gl.FLOAT;\r\n        let normalized = false;\r\n        let stride = 0;\r\n        let offset = 0;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.vertexAttribPointer(positionAttribute, size, type, normalized, stride, offset);\r\n        gl.enableVertexAttribArray(positionAttribute);\r\n\r\n        // Index buffer.\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n\r\n        // Texture coordinate buffer.\r\n        let textureCoordinateAttribute = gl.getAttribLocation(program, \"a_texcoord\");\r\n        size = 2;\r\n        type = gl.FLOAT;\r\n        normalized = false;\r\n        stride = 0;\r\n        offset = 0;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinateBuffer);\r\n        gl.vertexAttribPointer(textureCoordinateAttribute, size, type, normalized, stride, offset);\r\n        gl.enableVertexAttribArray(textureCoordinateAttribute);\r\n    };\r\n\r\n    /**\r\n     * Set the program uniforms.\r\n     */\r\n    let setUniforms = function()\r\n    {\r\n        let uniform = gl.getUniformLocation(program, \"u_frame\");\r\n    \r\n        // Set the uniform to the texture unit.\r\n        gl.uniform1i(uniform, unit);\r\n    };\r\n\r\n    /**\r\n     * Resize the canvas.\r\n     */\r\n    let resize = function( source )\r\n    {\r\n        if( source instanceof HTMLImageElement || source instanceof HTMLCanvasElement )\r\n        {\r\n            if( canvas.width != source.width || canvas.height != source.height )\r\n            {\r\n                canvas.width = source.width;\r\n                canvas.height = source.height;\r\n            }\r\n        }\r\n        else if( source instanceof HTMLVideoElement )\r\n        {\r\n            if( canvas.width != source.videoWidth || canvas.height != source.videoHeight )\r\n            {\r\n                canvas.width = source.videoWidth;\r\n                canvas.height = source.videoHeight;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render the pixel source to the canvas.\r\n     */\r\n    let render = function()\r\n    {\r\n        if(onUpdate) onUpdate();\r\n\r\n        resize(pixelSource);\r\n\r\n        updateTexture(pixelSource);\r\n    \r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n        gl.viewport(0, 0, canvas.width, canvas.height);\r\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\r\n    \r\n        handle = window.requestAnimationFrame(render);\r\n    };\r\n\r\n    /**\r\n     * Initialize the renderer.\r\n     */\r\n    let initialize = function()\r\n    {\r\n        createBuffers();\r\n        createTexture();\r\n        createProgram(VERTEX_SOURCE, FRAGMENT_SOURCE);\r\n        setProgram();\r\n        bindBuffers();\r\n        setUniforms();\r\n    };\r\n\r\n    /**\r\n     * Get the canvas.\r\n     */\r\n    let getCanvas = function()\r\n    {\r\n        return canvas;\r\n    };\r\n\r\n    /**\r\n     * Get the canvas' stream.\r\n     */\r\n    let getStream = function( frameRate = undefined )\r\n    {\r\n        if( !stream )\r\n        {\r\n            stream = canvas.captureStream(frameRate);\r\n        }\r\n\r\n        return stream;\r\n    };\r\n\r\n    /**\r\n     * Validate the pixel source type.\r\n     * Reference: https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\r\n     */\r\n    let validateSource = function( source )\r\n    {\r\n        let types = [HTMLImageElement, HTMLCanvasElement, HTMLVideoElement];\r\n        return types.some(type => source instanceof type);\r\n    };\r\n\r\n    /**\r\n     * Set the pixel source. Supported types are HTMLImageElement, HTMLCanvasElement and HTMLVideoElement.\r\n     */\r\n    let setSource = function( source )\r\n    {\r\n        if( validateSource(source) )\r\n        {\r\n            pixelSource = source;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Set the fragment shader.\r\n     */\r\n    let setShader = function( shader )\r\n    {\r\n        if( createProgram(VERTEX_SOURCE, shader) )\r\n        {\r\n            setProgram();\r\n            bindBuffers();\r\n            setUniforms();\r\n        }\r\n        else\r\n        {\r\n            createProgram(VERTEX_SOURCE, FRAGMENT_SOURCE);\r\n            setProgram();\r\n            bindBuffers();\r\n            setUniforms();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set an int uniform.\r\n     */\r\n    let setInt = function( name, value )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        gl.uniform1i(uniform, value);\r\n    };\r\n\r\n    /**\r\n     * Set a float uniform.\r\n     */\r\n    let setFloat = function( name, value )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        gl.uniform1f(uniform, value);\r\n    };\r\n\r\n    /**\r\n     * Set a float vector uniform.\r\n     */\r\n    let setVector = function( name, ...vector )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        switch( vector.length )\r\n        {\r\n            case 2: gl.uniform2f(uniform, vector); break;\r\n            case 3: gl.uniform3f(uniform, vector); break;\r\n            case 4: gl.uniform4f(uniform, vector); break;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set a float matrix uniform in column major order.\r\n     */\r\n    let setMatrix = function( name, matrix )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        switch( matrix.length )\r\n        {\r\n            case 4:  gl.uniformMatrix2fv(uniform, false, matrix); break;\r\n            case 9:  gl.uniformMatrix3fv(uniform, false, matrix); break;\r\n            case 16: gl.uniformMatrix4fv(uniform, false, matrix); break;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Start the rendering.\r\n     */\r\n    let start = function()\r\n    {\r\n        if( handle || !pixelSource )\r\n        {\r\n            return;\r\n        }\r\n\r\n        render();\r\n    };\r\n\r\n    /**\r\n     * Stop the rendering.\r\n     */\r\n    let stop = function()\r\n    {\r\n        if( !handle )\r\n        {\r\n            return;\r\n        }\r\n\r\n        window.cancelAnimationFrame(handle);\r\n        handle = null;\r\n    };\r\n\r\n    initialize();\r\n\r\n    return {\r\n        getCanvas,\r\n        getStream,\r\n        setSource,\r\n        setShader,\r\n        setUpdate,\r\n        setInt,\r\n        setFloat,\r\n        setVector,\r\n        setMatrix,\r\n        start,\r\n        stop\r\n    };\r\n}","import { useState, useRef, useEffect, useContext } from 'react'\r\nimport { Row, Col } from 'react-bootstrap'\r\nimport Shader from \"assets/shader.fs\"\r\nimport { CanvasRenderer } from 'lib_canvas_renderer'\r\nimport { MediaContext } from 'utils/ctx_mediadevices'\r\n\r\nlet video;\r\n\r\nexport default () => {\r\n    const canvasRef = useRef(null);\r\n    let [ctx, setCtx] = useState(null);\r\n    const media = useContext(MediaContext);\r\n    let {current: points} = useRef([]);\r\n\r\n    useEffect(() => {\r\n        (async () => {\r\n            var shader = await fetch(Shader).then(v => v.text());\r\n            ctx = new CanvasRenderer(canvasRef.current);\r\n            ctx.setShader(shader);\r\n            ctx.setUpdate(onUpdate);\r\n            setCtx(ctx);\r\n        })()\r\n\r\n        return () => {\r\n            if(ctx){\r\n                ctx.stop();\r\n                ctx.setUpdate(null);\r\n            } \r\n        }\r\n    }, []);\r\n\r\n    useEffect(()=>{\r\n        let video;\r\n        if(!ctx || !media.localStream) return;\r\n        (async ()=>{\r\n            video = document.createElement(\"video\");\r\n     \r\n            video.muted         = true;\r\n            video.width         = 320;\r\n            video.height        = 240;\r\n            video.autoplay      = true;\r\n            video.playsinline   = true;\r\n            video.src = video.srcObject = media.localStream;\r\n            \r\n            video.addEventListener('loadeddata', () => {\r\n                if(video.readyState >= 2) {\r\n                    video.play();\r\n                    ctx.setSource(video);\r\n                    ctx.start();\r\n\r\n                    (async ()=>{\r\n                        // Create a detector.\r\n                        //const detector = await poseDetection.createDetector(poseDetection.SupportedModels.BlazePose, { runtime: 'tfjs' });\r\n                        //const poses = await detector.estimatePoses(video);\r\n                        //console.log(poses)\r\n                    })()\r\n                }\r\n            });\r\n            \r\n        })();\r\n\r\n        return ()=>{\r\n            video?.pause();\r\n        }\r\n    },[ctx, media.localStream]);\r\n\r\n    async function onUpdate() {\r\n        ctx.setFloat(\"u_time\", performance.now() * 0.001);\r\n    }\r\n\r\n    return <>\r\n        <div id='shader'>\r\n            <Row>\r\n            <h1>Shader</h1>\r\n            <Col xs={12}>\r\n                <canvas id=\"shader-canvas\" ref={canvasRef} style={{objectFit:\"contain\", width:\"100%\", height:\"100%\", maxHeight:\"calc(100vh - 14rem)\"}}/>\r\n            </Col>\r\n        </Row>\r\n        </div>\r\n        <style global jsx>{`\r\n            \r\n        `}</style>\r\n    </>\r\n}"],"sourceRoot":""}