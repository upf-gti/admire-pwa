{"version":3,"sources":["pages/Pose.jsx","assets/shader.fs","../lib/canvasRenderer/canvasRenderer.js"],"names":["faceDetection","Pose","useState","x","y","w","h","center","setCenter","videoRef","useRef","media","useContext","MediaContext","onResults","image","detections","detection","boundingBox","L","landmarks","xCenter","yCenter","width","height","a","FaceDetection","locateFile","file","window","setOptions","selfieMode","model","minDetectionConfidence","initialize","id","setInterval","current","send","cancelAnimationFrame","destroy","useEffect","ready","reset","srcObject","localStream","play","start","validRange","Math","max","min","warningRange","dangerRange","message","abs","md","muted","style","transform","ref","variant","now","Range","value","className","console","warn","VERTEX_SOURCE","FRAGMENT_SOURCE","CanvasRenderer","canvas","HTMLCanvasElement","gl","getContext","handle","pixelSource","vertexBuffer","indexBuffer","textureCoordinateBuffer","texture","program","stream","onUpdate","createShader","source","type","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","log","getShaderInfoLog","error","FRAGMENT_SHADER","split","map","v","k","toString","padStart","join","createProgram","vertexSource","fragmentSource","vertexShader","VERTEX_SHADER","fragmentShader","attachShader","deleteShader","linkProgram","setProgram","useProgram","bindBuffers","positionAttribute","getAttribLocation","size","FLOAT","normalized","stride","offset","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","enableVertexAttribArray","ELEMENT_ARRAY_BUFFER","textureCoordinateAttribute","setUniforms","uniform","getUniformLocation","uniform1i","render","HTMLImageElement","HTMLVideoElement","videoWidth","videoHeight","target","TEXTURE_2D","internalFormat","RGBA","format","UNSIGNED_BYTE","texImage2D","updateTexture","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","viewport","drawElements","TRIANGLES","UNSIGNED_SHORT","requestAnimationFrame","createBuffer","bufferData","Float32Array","STATIC_DRAW","Uint16Array","createTexture","activeTexture","TEXTURE0","bindTexture","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","pixels","Uint8Array","getCanvas","getStream","frameRate","undefined","captureStream","setSource","some","validateSource","setShader","setUpdate","callback","setInt","name","setFloat","uniform1f","setVector","vector","length","uniform2f","uniform3f","uniform4f","setMatrix","matrix","uniformMatrix2fv","uniformMatrix3fv","uniformMatrix4fv","stop"],"mappings":"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","file":"static/js/3.c9469695.chunk.js","sourcesContent":["//https://github.com/google/mediapipe/issues/2346#issuecomment-888062233\r\n\r\nimport { useState, useRef, useEffect, useContext, useCallback  } from 'react'\r\nimport { Row, Col, ProgressBar, Form } from 'react-bootstrap'\r\nimport Shader from \"assets/shader.fs\"\r\nimport { CanvasRenderer } from 'lib_canvas_renderer'\r\nimport { MediaContext } from 'utils/ctx_mediadevices'\r\nimport { FaceDetection } from '@mediapipe/face_detection'\r\nimport { Camera } from '@mediapipe/camera_utils'\r\nimport { drawRectangle, drawLandmarks } from '@mediapipe/drawing_utils'\r\nimport MD from 'utils/md'\r\n//import { SelfieSegmentation } from \"@mediapipe/selfie_segmentation\";\r\n\r\nconsole.warn = ()=>{}\r\nlet video, camera, faceDetection;\r\n\r\nexport default function Pose() {\r\n    let [center, setCenter] = useState({x:0, y:0, w:0, h:0});\r\n    const canvasRef = useRef(null);\r\n    const videoRef = useRef(null);\r\n    let [ctx, setCtx] = useState(null);\r\n    const media = useContext(MediaContext);\r\n\r\n    function onResults({image, detections}) {\r\n        //ctx.save();\r\n        //ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\r\n        //ctx.drawImage(image, 0, 0, canvasRef.current.width, canvasRef.current.height);\r\n        for(let detection of detections) {\r\n            const { L, boundingBox, landmarks } = detection;\r\n            setCenter({\r\n                 x:boundingBox.xCenter\r\n                ,y:boundingBox.yCenter\r\n                ,w:boundingBox.width\r\n                ,h:boundingBox.height\r\n            });\r\n            try{\r\n                //drawRectangle(ctx, boundingBox, {color: 'blue', lineWidth: 1, fillColor: '#00000000'});\r\n                //drawLandmarks(ctx, landmarks, {color: 'red',radius: 1,});\r\n            }catch(e){}\r\n        }\r\n        //ctx.restore();\r\n    }\r\n\r\n    async function start(){\r\n\r\n        //Create the context\r\n        //ctx = ctx = canvasRef.current.getContext('2d');\r\n        //setCtx(ctx);\r\n        \r\n        faceDetection = new FaceDetection({\r\n            locateFile: (file) => {\r\n              return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4/${file}`;\r\n            },\r\n        });\r\n        window.faceDetection = faceDetection; \r\n        faceDetection.setOptions( {\r\n            selfieMode: true,\r\n            model: \"short\",\r\n            minDetectionConfidence: 0.5,\r\n        });\r\n\r\n        faceDetection.onResults(onResults);\r\n        await faceDetection.initialize();\r\n\r\n        const id = setInterval(async () => {\r\n            if(!videoRef.current){\r\n                return;\r\n            }\r\n            try{\r\n                await faceDetection.send({\r\n                    image: videoRef.current,\r\n                });\r\n            }catch(e){}\r\n        }, 120);\r\n\r\n        return () => {\r\n            cancelAnimationFrame(id);\r\n            faceDetection.destroy();\r\n        };\r\n    }\r\n\r\n    useEffect(() => {\r\n        if(!media.ready) return;\r\n        faceDetection?.reset();\r\n        videoRef.current.srcObject = media.localStream;\r\n        videoRef.current.play();\r\n        return start();\r\n    }, [media.ready, media.localStream]);\r\n\r\n    let validRange = Math.max(0,Math.min(100, 100 - center.w*400)),\r\n        warningRange = Math.max(0,Math.min(100, center.w*100)),\r\n        dangerRange = Math.max(0,Math.min(100, 100 - validRange - warningRange));\r\n\r\n    //intro message for the pose detection assesment step\r\n    let message = `\r\n    The pose detection step is used to detect the pose of the person in the image. Position yourself centered on the image within the green valid range.\r\n    If the conditions are not met, reposition yourself or the camera.\r\n    ${(center.w > .3) ? '* ❌ You are in the too close to the camera.': '* ✔️ Your distance to camera looks good.'}\r\n    ${(center.y - center.h < 0.0)\r\n        ? '* ❌ You are too far from the camera.'\r\n    :(center.y - center.h < 0.13)\r\n        ? '* ⚠️ Your face is to near to the top margin.' \r\n        : '* ✔️ Got enough space on top.'\r\n    }\r\n    ${(Math.abs(center.x - .5) > validRange*.01 ) \r\n        ?`* ❌ You are not centered at all.` \r\n    :(Math.abs(center.x - .5) > warningRange*.01 )\r\n        ?'* ⚠️ You haven\\'t enough margin of movement.'\r\n        :'* ✔️ You got enough space on the sides'\r\n    }\r\n    `;\r\n\r\n    return <>\r\n        <div id='pose'>\r\n        <h3 className=\"pt-2\"><b>Step 3: Positioning in frame</b></h3>\r\n            <Row>\r\n            <Col md={6}>\r\n                <video muted style={{ transform: \"rotateY(180deg)\", width:\"100%\" }} ref={videoRef}></video>\r\n                <ProgressBar>\r\n                    <ProgressBar variant = \"danger\"  key = {1} now = {dangerRange*.5} />\r\n                    <ProgressBar variant = \"warning\" key = {2} now = {warningRange*.5} />\r\n                    <ProgressBar variant = \"success\" key = {3} now = {validRange} />\r\n                    <ProgressBar variant = \"warning\" key = {4} now = {warningRange*.5} />\r\n                    <ProgressBar variant = \"danger\"  key = {5} now = {dangerRange*.5} />\r\n                </ProgressBar>\r\n                <Form.Range id=\"range\" value={center.x * 100}/>\r\n            </Col>\r\n            <Col md={6}>\r\n                <MD className=\"user-select-none\">{message}</MD>\r\n            </Col>\r\n\r\n            </Row>\r\n        </div>\r\n\r\n        <style global jsx>{`\r\n        @import \"src/variables.scss\";\r\n        /*#pose .row{\r\n            flex-direction: column !important;\r\n        }*/\r\n        @media only screen and (orientation: landscape) and (max-height: 671px) {           \r\n            #pose .row{\r\n                flex-direction: row !important;\r\n                .col{\r\n                    align-self: start;\r\n                }\r\n            }\r\n        }  \r\n    `}</style>\r\n    </>\r\n}","export default __webpack_public_path__ + \"static/media/shader.0b6fb8d4.fs\";","\"use strict\";\r\n\r\nconst VERTEX_SOURCE =\r\n`\r\nattribute vec3 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = vec4(a_position, 1.0);\r\n    v_texcoord = a_texcoord;\r\n}\r\n`;\r\n\r\nconst FRAGMENT_SOURCE =\r\n`\r\nprecision mediump float;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform sampler2D u_frame;\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = texture2D(u_frame, v_texcoord);\r\n}\r\n`;\r\n\r\nexport function CanvasRenderer( canvas )\r\n{\r\n    if( !(canvas instanceof HTMLCanvasElement) )\r\n    {\r\n        return null;\r\n    }\r\n\r\n    let gl = canvas.getContext(\"webgl\");\r\n    let handle = null;\r\n    let pixelSource = null;\r\n\r\n    let vertexBuffer = null;\r\n    let indexBuffer = null;\r\n    let textureCoordinateBuffer = null;\r\n\r\n    let texture = null;\r\n    let unit = 0;\r\n    let program = null;\r\n\r\n    let stream = null;\r\n    let onUpdate = null;\r\n\r\n    /**\r\n     * Create the vertex, index and texture coordinate buffers.\r\n     */\r\n    let createBuffers = function()\r\n    {\r\n        // Vertex buffer.\r\n        let vertices = [1, 1, 0, 1, -1, 0, -1, -1, 0, -1, 1, 0];\r\n        vertexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\r\n        // Index buffer.\r\n        let indices = [0, 1, 2, 0, 2, 3];\r\n        indexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n\r\n        // Texture coordinate buffer.\r\n        let textureCoordinates = [1, 0, 1, 1, 0, 1, 0, 0];\r\n        textureCoordinateBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinateBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n    };\r\n\r\n    function setUpdate( callback ){\r\n        onUpdate = callback;\r\n    }\r\n\r\n    /**\r\n     * Create the target texture.\r\n     */\r\n    let createTexture = function()\r\n    {\r\n        texture = gl.createTexture();\r\n    \r\n        // Active the texture unit.\r\n        gl.activeTexture(gl.TEXTURE0 + unit);\r\n    \r\n        // Bind the texture to the texture unit.\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    \r\n        // Turn off mip maps and set wrapping to clamp to edge so it will work regardless of the dimensions of the video.\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    \r\n        let target = gl.TEXTURE_2D;\r\n        let level = 0;\r\n        let internalFormat = gl.RGBA;\r\n        let width = 1;\r\n        let height = 1;\r\n        let border = 0;\r\n        let format = gl.RGBA;\r\n        let type = gl.UNSIGNED_BYTE;\r\n        let pixels = new Uint8Array([0, 0, 0, 255]);\r\n        gl.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels);\r\n    };\r\n\r\n    /**\r\n     * Update the target texture.\r\n     */\r\n    let updateTexture = function( source )\r\n    {\r\n        let target = gl.TEXTURE_2D;\r\n        let level = 0;\r\n        let internalFormat = gl.RGBA;\r\n        let format = gl.RGBA;\r\n        let type = gl.UNSIGNED_BYTE;\r\n        gl.texImage2D(target, level, internalFormat, format, type, source);\r\n    };\r\n\r\n    /**\r\n     * Create a shader.\r\n     */\r\n    let createShader = function( source, type )\r\n    {\r\n        let shader = gl.createShader(type);\r\n        gl.shaderSource(shader, source);\r\n        gl.compileShader(shader);\r\n    \r\n        let compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if( !compiled )\r\n        {\r\n            let log = gl.getShaderInfoLog(shader);\r\n            console.error(`Error while compiling  ${type === gl.FRAGMENT_SHADER?\"fragment\":\"vertex\"} shader: `,log);\r\n            console.error(source.split(\"\\n\").map( (v,k) => `${k.toString().padStart(4, '0')}\\t${v}`).join(\"\\n\"));\r\n            console.error(\"--------------------------------------------------------------------------------------\");\r\n            return null;\r\n        }\r\n    \r\n        return shader;\r\n    };\r\n\r\n    /**\r\n     * Create the program.\r\n     */\r\n    let createProgram = function( vertexSource, fragmentSource )\r\n    {\r\n        program = gl.createProgram();\r\n    \r\n        let vertexShader = createShader(vertexSource, gl.VERTEX_SHADER);\r\n        if( !vertexShader )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        let fragmentShader = createShader(fragmentSource, gl.FRAGMENT_SHADER);\r\n        if( !fragmentShader )\r\n        {\r\n            return false;\r\n        }\r\n    \r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n    \r\n        gl.deleteShader(vertexShader);\r\n        gl.deleteShader(fragmentShader);\r\n    \r\n        gl.linkProgram(program);\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Use the program.\r\n     */\r\n    let setProgram = function()\r\n    {\r\n        gl.useProgram(program);\r\n    };\r\n\r\n    /**\r\n     * Bind the vertex, index and texture coordinate buffers to the program.\r\n     */\r\n    let bindBuffers = function()\r\n    {\r\n        // Vertex buffer.\r\n        let positionAttribute = gl.getAttribLocation(program, \"a_position\");\r\n        let size = 3;\r\n        let type = gl.FLOAT;\r\n        let normalized = false;\r\n        let stride = 0;\r\n        let offset = 0;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.vertexAttribPointer(positionAttribute, size, type, normalized, stride, offset);\r\n        gl.enableVertexAttribArray(positionAttribute);\r\n\r\n        // Index buffer.\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n\r\n        // Texture coordinate buffer.\r\n        let textureCoordinateAttribute = gl.getAttribLocation(program, \"a_texcoord\");\r\n        size = 2;\r\n        type = gl.FLOAT;\r\n        normalized = false;\r\n        stride = 0;\r\n        offset = 0;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinateBuffer);\r\n        gl.vertexAttribPointer(textureCoordinateAttribute, size, type, normalized, stride, offset);\r\n        gl.enableVertexAttribArray(textureCoordinateAttribute);\r\n    };\r\n\r\n    /**\r\n     * Set the program uniforms.\r\n     */\r\n    let setUniforms = function()\r\n    {\r\n        let uniform = gl.getUniformLocation(program, \"u_frame\");\r\n    \r\n        // Set the uniform to the texture unit.\r\n        gl.uniform1i(uniform, unit);\r\n    };\r\n\r\n    /**\r\n     * Resize the canvas.\r\n     */\r\n    let resize = function( source )\r\n    {\r\n        if( source instanceof HTMLImageElement || source instanceof HTMLCanvasElement )\r\n        {\r\n            if( canvas.width != source.width || canvas.height != source.height )\r\n            {\r\n                canvas.width = source.width;\r\n                canvas.height = source.height;\r\n            }\r\n        }\r\n        else if( source instanceof HTMLVideoElement )\r\n        {\r\n            if( canvas.width != source.videoWidth || canvas.height != source.videoHeight )\r\n            {\r\n                canvas.width = source.videoWidth;\r\n                canvas.height = source.videoHeight;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render the pixel source to the canvas.\r\n     */\r\n    let render = function()\r\n    {\r\n        if(onUpdate) onUpdate();\r\n\r\n        resize(pixelSource);\r\n\r\n        updateTexture(pixelSource);\r\n    \r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n        gl.viewport(0, 0, canvas.width, canvas.height);\r\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\r\n    \r\n        handle = window.requestAnimationFrame(render);\r\n    };\r\n\r\n    /**\r\n     * Initialize the renderer.\r\n     */\r\n    let initialize = function()\r\n    {\r\n        createBuffers();\r\n        createTexture();\r\n        createProgram(VERTEX_SOURCE, FRAGMENT_SOURCE);\r\n        setProgram();\r\n        bindBuffers();\r\n        setUniforms();\r\n    };\r\n\r\n    /**\r\n     * Get the canvas.\r\n     */\r\n    let getCanvas = function()\r\n    {\r\n        return canvas;\r\n    };\r\n\r\n    /**\r\n     * Get the canvas' stream.\r\n     */\r\n    let getStream = function( frameRate = undefined )\r\n    {\r\n        if( !stream )\r\n        {\r\n            stream = canvas.captureStream(frameRate);\r\n        }\r\n\r\n        return stream;\r\n    };\r\n\r\n    /**\r\n     * Validate the pixel source type.\r\n     * Reference: https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\r\n     */\r\n    let validateSource = function( source )\r\n    {\r\n        let types = [HTMLImageElement, HTMLCanvasElement, HTMLVideoElement];\r\n        return types.some(type => source instanceof type);\r\n    };\r\n\r\n    /**\r\n     * Set the pixel source. Supported types are HTMLImageElement, HTMLCanvasElement and HTMLVideoElement.\r\n     */\r\n    let setSource = function( source )\r\n    {\r\n        if( validateSource(source) )\r\n        {\r\n            pixelSource = source;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Set the fragment shader.\r\n     */\r\n    let setShader = function( shader )\r\n    {\r\n        if( createProgram(VERTEX_SOURCE, shader) )\r\n        {\r\n            setProgram();\r\n            bindBuffers();\r\n            setUniforms();\r\n        }\r\n        else\r\n        {\r\n            createProgram(VERTEX_SOURCE, FRAGMENT_SOURCE);\r\n            setProgram();\r\n            bindBuffers();\r\n            setUniforms();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set an int uniform.\r\n     */\r\n    let setInt = function( name, value )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        gl.uniform1i(uniform, value);\r\n    };\r\n\r\n    /**\r\n     * Set a float uniform.\r\n     */\r\n    let setFloat = function( name, value )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        gl.uniform1f(uniform, value);\r\n    };\r\n\r\n    /**\r\n     * Set a float vector uniform.\r\n     */\r\n    let setVector = function( name, ...vector )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        switch( vector.length )\r\n        {\r\n            case 2: gl.uniform2f(uniform, vector); break;\r\n            case 3: gl.uniform3f(uniform, vector); break;\r\n            case 4: gl.uniform4f(uniform, vector); break;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set a float matrix uniform in column major order.\r\n     */\r\n    let setMatrix = function( name, matrix )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        switch( matrix.length )\r\n        {\r\n            case 4:  gl.uniformMatrix2fv(uniform, false, matrix); break;\r\n            case 9:  gl.uniformMatrix3fv(uniform, false, matrix); break;\r\n            case 16: gl.uniformMatrix4fv(uniform, false, matrix); break;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Start the rendering.\r\n     */\r\n    let start = function()\r\n    {\r\n        if( handle || !pixelSource )\r\n        {\r\n            return;\r\n        }\r\n\r\n        render();\r\n    };\r\n\r\n    /**\r\n     * Stop the rendering.\r\n     */\r\n    let stop = function()\r\n    {\r\n        if( !handle )\r\n        {\r\n            return;\r\n        }\r\n\r\n        window.cancelAnimationFrame(handle);\r\n        handle = null;\r\n    };\r\n\r\n    initialize();\r\n\r\n    return {\r\n        getCanvas,\r\n        getStream,\r\n        setSource,\r\n        setShader,\r\n        setUpdate,\r\n        setInt,\r\n        setFloat,\r\n        setVector,\r\n        setMatrix,\r\n        start,\r\n        stop\r\n    };\r\n}"],"sourceRoot":""}