{"version":3,"sources":["pages/Shader.jsx","assets/shader.fs","../lib/canvasRenderer/canvasRenderer.js"],"names":["canvasRef","useRef","useState","ctx","setCtx","media","useContext","MediaContext","current","onUpdate","a","setFloat","performance","now","useEffect","fetch","Shader","then","v","text","shader","CanvasRenderer","setShader","setUpdate","stop","video","localStream","document","createElement","muted","width","height","autoplay","playsinline","src","srcObject","addEventListener","readyState","play","setSource","start","pause","id","xs","ref","style","objectFit","maxHeight","VERTEX_SOURCE","FRAGMENT_SOURCE","canvas","HTMLCanvasElement","gl","getContext","handle","pixelSource","vertexBuffer","indexBuffer","textureCoordinateBuffer","texture","program","stream","createShader","source","type","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","log","getShaderInfoLog","console","error","FRAGMENT_SHADER","split","map","k","toString","padStart","join","createProgram","vertexSource","fragmentSource","vertexShader","VERTEX_SHADER","fragmentShader","attachShader","deleteShader","linkProgram","setProgram","useProgram","bindBuffers","positionAttribute","getAttribLocation","size","FLOAT","normalized","stride","offset","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","enableVertexAttribArray","ELEMENT_ARRAY_BUFFER","textureCoordinateAttribute","setUniforms","uniform","getUniformLocation","uniform1i","render","HTMLImageElement","HTMLVideoElement","videoWidth","videoHeight","target","TEXTURE_2D","internalFormat","RGBA","format","UNSIGNED_BYTE","texImage2D","updateTexture","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","viewport","drawElements","TRIANGLES","UNSIGNED_SHORT","window","requestAnimationFrame","createBuffer","bufferData","Float32Array","STATIC_DRAW","Uint16Array","createTexture","activeTexture","TEXTURE0","bindTexture","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","pixels","Uint8Array","getCanvas","getStream","frameRate","undefined","captureStream","some","validateSource","callback","setInt","name","value","uniform1f","setVector","vector","length","uniform2f","uniform3f","uniform4f","setMatrix","matrix","uniformMatrix2fv","uniformMatrix3fv","uniformMatrix4fv","cancelAnimationFrame"],"mappings":"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","file":"static/js/4.25418361.chunk.js","sourcesContent":["import { useState, useRef, useEffect, useContext } from 'react'\r\nimport { Row, Col } from 'react-bootstrap'\r\nimport Shader from \"assets/shader.fs\"\r\nimport { CanvasRenderer } from 'lib_canvas_renderer'\r\nimport { MediaContext } from 'utils/ctx_mediadevices'\r\n\r\nlet video;\r\n\r\nexport default () => {\r\n    const canvasRef = useRef(null);\r\n    let [ctx, setCtx] = useState(null);\r\n    const media = useContext(MediaContext);\r\n    let {current: points} = useRef([]);\r\n\r\n    useEffect(() => {\r\n        (async () => {\r\n            var shader = await fetch(Shader).then(v => v.text());\r\n            ctx = new CanvasRenderer(canvasRef.current);\r\n            ctx.setShader(shader);\r\n            ctx.setUpdate(onUpdate);\r\n            setCtx(ctx);\r\n        })()\r\n\r\n        return () => {\r\n            if(ctx){\r\n                ctx.stop();\r\n                ctx.setUpdate(null);\r\n            } \r\n        }\r\n    }, []);\r\n\r\n    useEffect(()=>{\r\n        let video;\r\n        if(!ctx || !media.localStream) return;\r\n        (async ()=>{\r\n            video = document.createElement(\"video\");\r\n     \r\n            video.muted         = true;\r\n            video.width         = 320;\r\n            video.height        = 240;\r\n            video.autoplay      = true;\r\n            video.playsinline   = true;\r\n            video.src = video.srcObject = media.localStream;\r\n            \r\n            video.addEventListener('loadeddata', () => {\r\n                if(video.readyState >= 2) {\r\n                    video.play();\r\n                    ctx.setSource(video);\r\n                    ctx.start();\r\n\r\n                    (async ()=>{\r\n                        // Create a detector.\r\n                        //const detector = await poseDetection.createDetector(poseDetection.SupportedModels.BlazePose, { runtime: 'tfjs' });\r\n                        //const poses = await detector.estimatePoses(video);\r\n                        //console.log(poses)\r\n                    })()\r\n                }\r\n            });\r\n            \r\n        })();\r\n\r\n        return ()=>{\r\n            video?.pause();\r\n        }\r\n    },[ctx, media.localStream]);\r\n\r\n    async function onUpdate() {\r\n        ctx.setFloat(\"u_time\", performance.now() * 0.001);\r\n    }\r\n\r\n    return <>\r\n        <div id='shader'>\r\n            <Row>\r\n            <h1>Shader</h1>\r\n            <Col xs={12}>\r\n                <canvas id=\"shader-canvas\" ref={canvasRef} style={{objectFit:\"contain\", width:\"100%\", height:\"100%\", maxHeight:\"calc(100vh - 14rem)\"}}/>\r\n            </Col>\r\n        </Row>\r\n        </div>\r\n        <style global jsx>{`\r\n            \r\n        `}</style>\r\n    </>\r\n}","export default __webpack_public_path__ + \"static/media/shader.0b6fb8d4.fs\";","\"use strict\";\r\n\r\nconst VERTEX_SOURCE =\r\n`\r\nattribute vec3 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = vec4(a_position, 1.0);\r\n    v_texcoord = a_texcoord;\r\n}\r\n`;\r\n\r\nconst FRAGMENT_SOURCE =\r\n`\r\nprecision mediump float;\r\n\r\nvarying vec2 v_texcoord;\r\n\r\nuniform sampler2D u_frame;\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = texture2D(u_frame, v_texcoord);\r\n}\r\n`;\r\n\r\nexport function CanvasRenderer( canvas )\r\n{\r\n    if( !(canvas instanceof HTMLCanvasElement) )\r\n    {\r\n        return null;\r\n    }\r\n\r\n    let gl = canvas.getContext(\"webgl\");\r\n    let handle = null;\r\n    let pixelSource = null;\r\n\r\n    let vertexBuffer = null;\r\n    let indexBuffer = null;\r\n    let textureCoordinateBuffer = null;\r\n\r\n    let texture = null;\r\n    let unit = 0;\r\n    let program = null;\r\n\r\n    let stream = null;\r\n    let onUpdate = null;\r\n\r\n    /**\r\n     * Create the vertex, index and texture coordinate buffers.\r\n     */\r\n    let createBuffers = function()\r\n    {\r\n        // Vertex buffer.\r\n        let vertices = [1, 1, 0, 1, -1, 0, -1, -1, 0, -1, 1, 0];\r\n        vertexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\r\n        // Index buffer.\r\n        let indices = [0, 1, 2, 0, 2, 3];\r\n        indexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n\r\n        // Texture coordinate buffer.\r\n        let textureCoordinates = [1, 0, 1, 1, 0, 1, 0, 0];\r\n        textureCoordinateBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinateBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n    };\r\n\r\n    function setUpdate( callback ){\r\n        onUpdate = callback;\r\n    }\r\n\r\n    /**\r\n     * Create the target texture.\r\n     */\r\n    let createTexture = function()\r\n    {\r\n        texture = gl.createTexture();\r\n    \r\n        // Active the texture unit.\r\n        gl.activeTexture(gl.TEXTURE0 + unit);\r\n    \r\n        // Bind the texture to the texture unit.\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    \r\n        // Turn off mip maps and set wrapping to clamp to edge so it will work regardless of the dimensions of the video.\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    \r\n        let target = gl.TEXTURE_2D;\r\n        let level = 0;\r\n        let internalFormat = gl.RGBA;\r\n        let width = 1;\r\n        let height = 1;\r\n        let border = 0;\r\n        let format = gl.RGBA;\r\n        let type = gl.UNSIGNED_BYTE;\r\n        let pixels = new Uint8Array([0, 0, 0, 255]);\r\n        gl.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels);\r\n    };\r\n\r\n    /**\r\n     * Update the target texture.\r\n     */\r\n    let updateTexture = function( source )\r\n    {\r\n        let target = gl.TEXTURE_2D;\r\n        let level = 0;\r\n        let internalFormat = gl.RGBA;\r\n        let format = gl.RGBA;\r\n        let type = gl.UNSIGNED_BYTE;\r\n        gl.texImage2D(target, level, internalFormat, format, type, source);\r\n    };\r\n\r\n    /**\r\n     * Create a shader.\r\n     */\r\n    let createShader = function( source, type )\r\n    {\r\n        let shader = gl.createShader(type);\r\n        gl.shaderSource(shader, source);\r\n        gl.compileShader(shader);\r\n    \r\n        let compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if( !compiled )\r\n        {\r\n            let log = gl.getShaderInfoLog(shader);\r\n            console.error(`Error while compiling  ${type === gl.FRAGMENT_SHADER?\"fragment\":\"vertex\"} shader: `,log);\r\n            console.error(source.split(\"\\n\").map( (v,k) => `${k.toString().padStart(4, '0')}\\t${v}`).join(\"\\n\"));\r\n            console.error(\"--------------------------------------------------------------------------------------\");\r\n            return null;\r\n        }\r\n    \r\n        return shader;\r\n    };\r\n\r\n    /**\r\n     * Create the program.\r\n     */\r\n    let createProgram = function( vertexSource, fragmentSource )\r\n    {\r\n        program = gl.createProgram();\r\n    \r\n        let vertexShader = createShader(vertexSource, gl.VERTEX_SHADER);\r\n        if( !vertexShader )\r\n        {\r\n            return false;\r\n        }\r\n\r\n        let fragmentShader = createShader(fragmentSource, gl.FRAGMENT_SHADER);\r\n        if( !fragmentShader )\r\n        {\r\n            return false;\r\n        }\r\n    \r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n    \r\n        gl.deleteShader(vertexShader);\r\n        gl.deleteShader(fragmentShader);\r\n    \r\n        gl.linkProgram(program);\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Use the program.\r\n     */\r\n    let setProgram = function()\r\n    {\r\n        gl.useProgram(program);\r\n    };\r\n\r\n    /**\r\n     * Bind the vertex, index and texture coordinate buffers to the program.\r\n     */\r\n    let bindBuffers = function()\r\n    {\r\n        // Vertex buffer.\r\n        let positionAttribute = gl.getAttribLocation(program, \"a_position\");\r\n        let size = 3;\r\n        let type = gl.FLOAT;\r\n        let normalized = false;\r\n        let stride = 0;\r\n        let offset = 0;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.vertexAttribPointer(positionAttribute, size, type, normalized, stride, offset);\r\n        gl.enableVertexAttribArray(positionAttribute);\r\n\r\n        // Index buffer.\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n\r\n        // Texture coordinate buffer.\r\n        let textureCoordinateAttribute = gl.getAttribLocation(program, \"a_texcoord\");\r\n        size = 2;\r\n        type = gl.FLOAT;\r\n        normalized = false;\r\n        stride = 0;\r\n        offset = 0;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinateBuffer);\r\n        gl.vertexAttribPointer(textureCoordinateAttribute, size, type, normalized, stride, offset);\r\n        gl.enableVertexAttribArray(textureCoordinateAttribute);\r\n    };\r\n\r\n    /**\r\n     * Set the program uniforms.\r\n     */\r\n    let setUniforms = function()\r\n    {\r\n        let uniform = gl.getUniformLocation(program, \"u_frame\");\r\n    \r\n        // Set the uniform to the texture unit.\r\n        gl.uniform1i(uniform, unit);\r\n    };\r\n\r\n    /**\r\n     * Resize the canvas.\r\n     */\r\n    let resize = function( source )\r\n    {\r\n        if( source instanceof HTMLImageElement || source instanceof HTMLCanvasElement )\r\n        {\r\n            if( canvas.width != source.width || canvas.height != source.height )\r\n            {\r\n                canvas.width = source.width;\r\n                canvas.height = source.height;\r\n            }\r\n        }\r\n        else if( source instanceof HTMLVideoElement )\r\n        {\r\n            if( canvas.width != source.videoWidth || canvas.height != source.videoHeight )\r\n            {\r\n                canvas.width = source.videoWidth;\r\n                canvas.height = source.videoHeight;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render the pixel source to the canvas.\r\n     */\r\n    let render = function()\r\n    {\r\n        if(onUpdate) onUpdate();\r\n\r\n        resize(pixelSource);\r\n\r\n        updateTexture(pixelSource);\r\n    \r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n        gl.viewport(0, 0, canvas.width, canvas.height);\r\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\r\n    \r\n        handle = window.requestAnimationFrame(render);\r\n    };\r\n\r\n    /**\r\n     * Initialize the renderer.\r\n     */\r\n    let initialize = function()\r\n    {\r\n        createBuffers();\r\n        createTexture();\r\n        createProgram(VERTEX_SOURCE, FRAGMENT_SOURCE);\r\n        setProgram();\r\n        bindBuffers();\r\n        setUniforms();\r\n    };\r\n\r\n    /**\r\n     * Get the canvas.\r\n     */\r\n    let getCanvas = function()\r\n    {\r\n        return canvas;\r\n    };\r\n\r\n    /**\r\n     * Get the canvas' stream.\r\n     */\r\n    let getStream = function( frameRate = undefined )\r\n    {\r\n        if( !stream )\r\n        {\r\n            stream = canvas.captureStream(frameRate);\r\n        }\r\n\r\n        return stream;\r\n    };\r\n\r\n    /**\r\n     * Validate the pixel source type.\r\n     * Reference: https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\r\n     */\r\n    let validateSource = function( source )\r\n    {\r\n        let types = [HTMLImageElement, HTMLCanvasElement, HTMLVideoElement];\r\n        return types.some(type => source instanceof type);\r\n    };\r\n\r\n    /**\r\n     * Set the pixel source. Supported types are HTMLImageElement, HTMLCanvasElement and HTMLVideoElement.\r\n     */\r\n    let setSource = function( source )\r\n    {\r\n        if( validateSource(source) )\r\n        {\r\n            pixelSource = source;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Set the fragment shader.\r\n     */\r\n    let setShader = function( shader )\r\n    {\r\n        if( createProgram(VERTEX_SOURCE, shader) )\r\n        {\r\n            setProgram();\r\n            bindBuffers();\r\n            setUniforms();\r\n        }\r\n        else\r\n        {\r\n            createProgram(VERTEX_SOURCE, FRAGMENT_SOURCE);\r\n            setProgram();\r\n            bindBuffers();\r\n            setUniforms();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set an int uniform.\r\n     */\r\n    let setInt = function( name, value )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        gl.uniform1i(uniform, value);\r\n    };\r\n\r\n    /**\r\n     * Set a float uniform.\r\n     */\r\n    let setFloat = function( name, value )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        gl.uniform1f(uniform, value);\r\n    };\r\n\r\n    /**\r\n     * Set a float vector uniform.\r\n     */\r\n    let setVector = function( name, ...vector )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        switch( vector.length )\r\n        {\r\n            case 2: gl.uniform2f(uniform, vector); break;\r\n            case 3: gl.uniform3f(uniform, vector); break;\r\n            case 4: gl.uniform4f(uniform, vector); break;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set a float matrix uniform in column major order.\r\n     */\r\n    let setMatrix = function( name, matrix )\r\n    {\r\n        let uniform = gl.getUniformLocation(program, name);\r\n        switch( matrix.length )\r\n        {\r\n            case 4:  gl.uniformMatrix2fv(uniform, false, matrix); break;\r\n            case 9:  gl.uniformMatrix3fv(uniform, false, matrix); break;\r\n            case 16: gl.uniformMatrix4fv(uniform, false, matrix); break;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Start the rendering.\r\n     */\r\n    let start = function()\r\n    {\r\n        if( handle || !pixelSource )\r\n        {\r\n            return;\r\n        }\r\n\r\n        render();\r\n    };\r\n\r\n    /**\r\n     * Stop the rendering.\r\n     */\r\n    let stop = function()\r\n    {\r\n        if( !handle )\r\n        {\r\n            return;\r\n        }\r\n\r\n        window.cancelAnimationFrame(handle);\r\n        handle = null;\r\n    };\r\n\r\n    initialize();\r\n\r\n    return {\r\n        getCanvas,\r\n        getStream,\r\n        setSource,\r\n        setShader,\r\n        setUpdate,\r\n        setInt,\r\n        setFloat,\r\n        setVector,\r\n        setMatrix,\r\n        start,\r\n        stop\r\n    };\r\n}"],"sourceRoot":""}